---
title: 设计模式（一）
date: 2023-03-31 20:10:55
tags: 设计模式
---

### 目的
写出可扩展、可读、可维护的代码


### 说明

文章内容是对于 [极客时间-设计模式之美](https://time.geekbang.org/column/intro/100039001?tab=catalog)的学习笔记

本篇只是一个大纲

文章中所有示例采用`go`语言实现，由于`go`的特性（没有继承 隐式接口定义/duck typing），实现方式和标准定义有些区别。


### 代码质量评判标准（不是全部）

- 可维护性

  易维护： 在不破坏原有代码设计、不引入新的bug的基础上，能够快速添加或修改代码。

  维护代码的时间是远大于编写时间的。

  这是一个对于项目整体代码的评判。代码量、技术复杂程度、文档全面、成员水平等等都诸多因素相关。
- 可读性

  是否符合代码规范、注释是否详尽、模块划分是否清晰等等。 （CR时别人是否容易看懂）
- 可扩展性

  可扩展很大程度上决定了代码的可维护性。

  "对修改关闭，对扩展开放。"
- 灵活性

  一段代码写的易扩展、易用或易复用，我们都可以称之为写的灵活
- 简洁性

  "KISS"(Keep It Simple, Stupid)
- 可复用性

  减少重复代码的编写

  面向相对象的继承、多态特性

  "DRY"（Don't Repeat Yourself）

  "单一职责原则"

  重构技巧中的解耦、高内聚、低耦合
- 可测试性

#### 小结

我们后续讲的设计思想、原则、模式这些都是为了达成以上目的。

面向对象中的继承、多态能让我们写出可复用的代码；

编码规范能让我们写出可读性好的代码；

设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；

设计模式可以让我们写出易扩展的代码；

持续重构可以时刻保持代码的可维护性等等。


### 面向对象

封装、抽象、继承、多态

"基于接口为非实现编程"

多用组合少用继承


### 设计原则

设计初衷、解决问题、应用场景

SOLID原则：

- SRP 单一职责原则
- OCP 开闭原则
- LSP 里式替换原则
- ISP 接口隔离原则
- DIP 依赖倒置原则

DRY原则、KISS原则、YAGNI原则、LOD原则


### 设计模式

解决问题、应用场景

| 创建型                       | 结构型                                  | 行为型                                                       |
|---------------------------|--------------------------------------|-----------------------------------------------------------|
| 单例模式 <br> 工厂模式 <br> 建造者模式 | 代理模式 <br> 桥接模式 <br> 装饰器模式 <br> 适配器模式 | 观察者模式 <br> 模版模式 <br> 策略模式 <br> 职责链模式 <br> 迭代器模式 <br> 状态模式 |
|                           |                                      |                                                           |
| 原型模式                      | 门面模式 <br>   组合模式 <br> 享元模式           | 访问者模式 <br>  备忘录模式 <br>  命令模式 <br>  解释器模式 <br>  中介模式       |


### 编码规范


### 代码重构

- 重构的目的、对象、时机、方法
- 重构的保证：单元测试和代码的可测试性
- 大重构 与 小重构


#### 小结

以上五块内容之间的关系：

- 面向对象编程其丰富的特性（封装、抽象、继承、多态），是很多设计原则、设计模式编码实现的基础
- 设计原则是知道我们代码设计的经验总结，对于在某些场景下，应该使用那种设计模式，具有指导意义。
- 设计模式是针对开发过程中遇到的一些问题，总结出来的一套行之有效的解决方案或设计思路。它比设计原则更加具体、可执行。设计模式的主要目的是提高代码的可扩展性。
- 编程规范解决的是代码可读性问题，更加具体、细节、可落地。是我们进行小重构的理论基础。
- 重构是保持代码质量不下降的手段。以上是我们进行重构的理论基础。

### 主题

不要过度设计（如果是小项目 不重要 练练手还是可以的）。

重要的还是分析解决问题的能力，不要"学生气"，为了用而用。

知识积累+刻意练习

代码质量意识和设计意识

脱离业务谈架构都是"耍流氓"。不同场景对于代码的要求是不同的（有的需要快速实现，有的需要足够健壮 可扩展）。

模式是死的，人是活的。不要照搬设计模式定义，结合实际场景做调整/融合。


### 题外话

#### Code Review的一些点

- 代码结构是否合理
- 代码是否易理解
- 业务是否正确
- 异常处理是否健全
- 并发安全
- 性能是否满足需求
- 是否符合编码规范

[Google Code Review 最佳实践](https://google.github.io/eng-practices/review/reviewer/)


### 业务框架

MVC       --->    DDD

贫血模型    ---> 充血模型

#### 一些诉求

- 扩展性
- 易用、易维护
- 请求追踪/log
- 监控 （生态）
- 可测试性
- IDL
- 开发 生产环境的统一

#### 目录结构

```
├── biz // 业务层代码
│   ├── dal // 第三方实例化 ep: 数据库连接、缓存
│   ├── dao // dao层 定义do 输出 dto
│   ├── domain // 领域逻辑 dto <-> do 
│   ├── errors // 业务层错误定义 
│   ├── handler // controller/service 接收vo -> dto -> vo 
│   ├── model // vo 结构定义
│   └── router // 路由
├── cmd
│   ├── server // web server
│   └── tool
├── configs
│   └── config.go
├── go.mod
├── go.sum
├── idl // pb（IDL）
│   ├── api.proto
│   └── watch
├── main.go
├── Makefile // 构造工具
├── pkg // 工具类
└── run // 配置 以及 docker启动文件

```
 