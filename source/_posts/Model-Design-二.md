---
title: 设计模式（二）
date: 2023-04-03 11:13:49
tags: 设计模式
---

### 说明

在此是 面向对象部分的简单整理

### 面向对象

#### 封装

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。

封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

#### 抽象

抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。

抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

#### 继承

"多用组合少用继承"

#### 多态

编程语言要支持子类可以重写（override）父类中的方法。

利用接口类同样可以实现多态。

duck-typing语法实现多态： 只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系。

多态特性能提高代码的可扩展性和复用性。

#### 接口 & 抽象类 区别

### 基于接口而非实现编程

"基于抽象而非实现编程"

封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节。

接口的定义只表明做什么，而不是怎么做。（比如对于图片存储 我们在一起的是存储 而不在意是存储在阿里云还是本地磁盘，所以不要带上aliyun类似的具体名称）


### 多用组合少用继承

继承层次过深、过复杂会影响到代码的可读性、可维护性。

代码复用我们可以通过组合和委托（实例化同一个类作为属性）来实现。
<details>
  <summary>委托示例</summary>

        package main

        type Flyable interface {
            fly()
        }
        
        type EggLayable interface {
            egg()
        }
        
        type FlyAbility struct {
        }
        
        func (f *FlyAbility) fly() {
            // do something
        }
        
        type EggAbility struct {
        }
        
        func (e *EggAbility) egg() {
            // do something
        }
        
        
        type Sparrow struct {
            eggIns EggAbility // 组合
            flyIns FlyAbility
        }
        
        func (s *Sparrow) fly() {
            s.eggIns.egg() // 委托
        }
        
        func (s *Sparrow) egg() {
            s.flyIns.fly()
        }

</details>


